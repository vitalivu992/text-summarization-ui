import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import * as actions from './redux/actions';

import { Header, Button, Divider, Label, Icon, Form, Grid } from 'semantic-ui-react';

export class ToolPage extends Component {
  static propTypes = {
    summarize: PropTypes.object.isRequired,
    actions: PropTypes.object.isRequired,
  };

  render() {
    const { summarizePending, summarizeError, summarizeTime,
      loadExamplePending, loadExampleError,
      rateSummaryTextPending,
      rouge1Score, rouge2Score, rougeLScore,
      article, goldSummary, computeSummary } = this.props.summarize;

    const { summarize, loadExample, rateSummaryText } = this.props.actions;

    const handleChange = event => {
      this.props.summarize[event.target.name] = event.target.value;
      console.log("Length of",event.target.name, this.props.summarize[event.target.name].length);
     };

    const loadSummary = () => {
      summarize(article);
    }
    const loadRateSummary = () => {
      rateSummaryText(goldSummary, computeSummary);
    }

    return (
      <div className="summarize-tool-page">
        <Header as='h1'>Text summarization</Header>
        <Button width={2} primary={!loadExamplePending} disabled={loadExamplePending}
          onClick={loadExample} size='tiny' >
          <Icon name='random' /> Load an example
              </Button>
        <Divider />
        <Form onSubmit={summarize} loading={summarizePending || loadExamplePending || rateSummaryTextPending}>
          <Grid columns={2} relaxed='very'>
            <Grid.Column>
              <Form.TextArea label='Input article' placeholder={article != null ? article : 'Your article'} size='large'
                name='article' onChange={handleChange} className='large-text-area-x2' error={loadExampleError && loadExampleError.message ? { content: loadExampleError.message } : null} />
            </Grid.Column>

            <Grid.Column>
              <Form.TextArea label='Gold summary' placeholder={goldSummary != null ? goldSummary : 'This is the gold summary'}
                name='goldSummary' onChange={handleChange} className='large-text-area' error={loadExampleError && loadExampleError.message ? { content: loadExampleError.message } : null} />

              <Button width={2} primary={!summarizePending} disabled={summarizePending}
                onClick={loadSummary} size='tiny' >
                <Icon name='comment alternate' /> Summarize
              </Button>
              {summarizeTime !== 0 && <Label as='a'><Icon name='clock' /> {parseFloat(summarizeTime).toFixed(2)} seconds</Label>}
              <Divider />
              <Form.TextArea label='Computed summary' value={computeSummary != null ? computeSummary : 'This is the summary generated by our model'}
                name='computeSummary' onChange={handleChange} className='large-text-area' error={summarizeError !== null && summarizeError.message ? { content: summarizeError.message } : null} />

              <Button width={2} primary={!rateSummaryTextPending} disabled={rateSummaryTextPending}
                onClick={loadRateSummary} size='tiny' >
                <Icon name='check square' /> Rate
              </Button>
              {rouge1Score !== 0 && <Label as='a'> ROUGE-1 <Label.Detail>{parseFloat(rouge1Score * 100).toFixed(2)}</Label.Detail> </Label>}
              {rouge2Score !== 0 && <Label as='a'> ROUGE-2 <Label.Detail>{parseFloat(rouge2Score * 100).toFixed(2)}</Label.Detail> </Label>}
              {rougeLScore !== 0 && <Label as='a'> ROUGE-L <Label.Detail>{parseFloat(rougeLScore * 100).toFixed(2)}</Label.Detail> </Label>}
            </Grid.Column>
          </Grid>
        </Form>
      </div>
    );
  }
}

/* istanbul ignore next */
function mapStateToProps(state) {
  return {
    summarize: state.summarize,
  };
}

/* istanbul ignore next */
function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators({ ...actions }, dispatch)
  };
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(ToolPage);
